package main

// MIT License

// Copyright (c) 2022 Mobile Data Books, LLC

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import (
	"flag"
	"fmt"
	"net/http"
	"regexp"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/validator/v10"
	"github.com/pkg/profile"

	// docs is generated by Swag CLI, you have to import it.

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "mobiledatabooks.com/docs"
)

// go tool pprof -png -call_tree -cum -nodecount=$NODECOUNT  -focus=Benchmark -hide=benchm
// database is a simple in-memory data store;
// database methods are
// safe to call concurrently.
type database map[string]Item

var dbmux sync.Mutex

// Binding from JSON with POST.
type Item struct {
	ProduceCode string `json:"code" binding:"required,isproducecode"`    // ProduceCode is a UUID
	Name        string `json:"name" binding:"required,alphanumandspace"` // Name is a string with only alphanumeric characters and spaces
	UnitPrice   string `json:"price" binding:"required,isunitprice"`     // UnitPrice is a number with up to 2 decimal places (e.g. $3.41)
}

// URL binding
// isProduceCode is the validation function for validating if the field's value is a valid custom UUID.
type ProduceId struct {
	ProduceCode string `uri:"code" binding:"required,isproducecode"` // ProduceCode is a UUID binding with required and isproducecode validation rules applied to it. The validation function is isproducecode.
}

//

// setupRouter is a function that creates a gin.Engine and sets up the routes. It returns the gin.Engine. It is called by main. It is not exported.
//
// .setupRouter
// [source,go]
// ----
// include::${gad:current:fq}[tag=setupRouter,indent=0]
// ----
// tag::setupRouter[]
func (db database) setupRouter() *gin.Engine { // db is the database map that is passed to the function. It is a pointer to the database map.

	// ginMode := "debug"
	// gin.SetMode(ginMode)
	// r := gin.New()
	// r.Use(gin.Recovery())

	r := gin.Default() // Create a new gin.Engine.

	if v, ok := binding.Validator.Engine().(*validator.Validate); ok { // Get the validator instance from the binding.Validator.Engine(). It is a pointer to the validator.Validate.
		v.RegisterValidation("isproducecode", IsProduceCode) // Register the validation function IsProduceCode with the validator.Validate instance. The validation function is called when the field is validated.
	}

	if v, ok := binding.Validator.Engine().(*validator.Validate); ok { //  Get the validator instance from the binding.Validator.Engine(). It is a pointer to the validator.Validate.
		v.RegisterValidation("alphanumandspace", isAlphaNumericAndSpace) // Register the validation function isAlphaNumericAndSpace with the validator.Validate instance. The validation function is called when the field is validated.
	}

	if v, ok := binding.Validator.Engine().(*validator.Validate); ok { //  Get the validator instance from the binding.Validator.Engine(). It is a pointer to the validator.Validate. The validator.Validate instance is used to validate the fields of the struct.
		v.RegisterValidation("isunitprice", IsUnitPrice) //  Register the validation function IsUnitPrice with the validator.Validate instance. The validation function is called when the field is validated.
	}

	r.GET("/api/v1/ping", ping) // Create a new route for the GET method on the /ping path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched.

	r.GET("/api/v1/items", db.items)

	r.POST("/api/v1/add", db.add)

	// This handler will match /item/A12T-4GH7-QPL9-3N4M but will not match /item/ or /item
	r.GET("/api/v1/item/:code", db.itemCode)

	r.GET("/api/v1/delete/:code", db.deleteCode)
	r.NoRoute(func(c *gin.Context) {
		res := "endpoint not found"
		c.JSON(http.StatusMethodNotAllowed, gin.H{"error": res}) // The response is sent to the client. The response is a JSON with the status code and the error. The status code is 405 and the error is the value of the method is not allowed.
	})
	return r // Return the router. The router is a Gin engine.
}

// @BasePath /api/v1

// ping godoc
// @Summary ping
// @Schemes
// @Description do ping
// @Tags example
// @Accept json
// @Produce json
// @Success 200 {string} ok
// @Router /ping [get]
func ping(c *gin.Context) { // Create a new route for the GET method on the /ping path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched.
	// http://localhost:8080/api/v1/ping
	c.String(http.StatusOK, "pong") // The response is sent to the client. The response is a string with the status code and the message. The status code is 200 and the message is "pong". The response is sent to the client.
}

// items godoc
// @Summary List Items
// @Schemes
// @Description List all items
// @Tags example
// @Accept json
// @Produce json
// @Success 200 {string} ok
// @Router /items [get]
func (db database) items(c *gin.Context) { // Create a new route for the GET method on the /items path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched.
	// http://localhost:8080/api/v1/items
	// The order of map iteration is unspecified, and different
	// implementations might use a different hash function,
	// leading to a different ordering.
	//
	// We need predictable key ordering which also enables testing.
	//
	// To enumerate the key/value pairs in order, we must sort
	// the keys explicitly, for instance, using the Strings
	// function from the sort package if the keys are strings.
	//
	dbmux.Lock()         // Lock the database map. The database map is a pointer to the database map.
	defer dbmux.Unlock() // Unlock the database map.
	var keys []string    // Create a new slice of strings.  The slice is used to store the keys of the database map. The slice is created empty.
	for k := range db {  // For each key in the database map.  The key is a string. The key is assigned to k.
		keys = append(keys, k) // The key is appended to the slice of keys.
	}
	sort.Strings(keys)       // Sort the keys of the database map. The keys are sorted in alphabetical order.
	var items []Item         // Create a new slice of Items. The slice is used to store the items of the database map. The slice is created empty.
	for _, k := range keys { // For each key in the database map.  The key is a string. The key is assigned to k.
		v := db[k]                   // Get the value of the key from the database map. The value is assigned to v.
		var item Item                // Create a new Item. The Item is used to store the item of the database map. The Item is created empty.
		item.ProduceCode = k         // Set the ProduceCode of the Item to the key. The key is a string. The key is assigned to k. The key is assigned to the ProduceCode of the Item.
		item.Name = v.Name           // Set the Name of the Item to the value. The value is a string. The value is assigned to v. The value is assigned to the Name of the Item.
		item.UnitPrice = v.UnitPrice // Set the UnitPrice of the Item to the value. The value is a string. The value is assigned to v. The value is assigned to the UnitPrice of the Item.
		items = append(items, item)  // Append the Item to the slice of Items. The Item is added to the slice of Items.
	}
	c.JSON(http.StatusOK, items) // The response is sent to the client. The response is a JSON with the status code and the items. The status code is 200 and the items are the items of the database map.
}

// add godoc
// @Summary Add Item
// @Schemes
// @Description Add an item(s). Expects JSON array. Send single item in array
// @Tags example
// @Accept json
// @Produce json
// @Success 200 {string} ok
// @Failure 400 {string} error
// @Router /add [post]
func (db database) add(c *gin.Context) { // Create a new route for the POST method on the /add path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched.
	var items []Item                                 // Create a new slice of Items. The slice is used to store the items of the database map. The slice is created empty.
	if err := c.ShouldBindJSON(&items); err != nil { // ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) // The response is sent to the client. The response is a JSON with the status code and the error. The status code is 400 and the error is the error message.
	} else {
		itemsAdded := false          // Create a new boolean. The boolean is used to store the value of whether the items were added to the database map. The boolean is created with the value false. The boolean is assigned to itemsAdded.
		for _, item := range items { // For each item in the slice of Items.
			item.ProduceCode = strings.ToUpper(item.ProduceCode) // Set the ProduceCode of the item to the upper case of the ProduceCode of the item. The ProduceCode of the item is a string.
			if _, ok := db[item.ProduceCode]; ok {               // If the ProduceCode of the item is in the database map.
				res := "item exist, not added" // Create a new string. The string is used to store the value of the item that was not added to the database map. The string is created with the value "item exist, not added". The string is assigned to res.
				// log.Printf("r.POST(/add):%v:%s\n", item, res)
				c.JSON(http.StatusOK, gin.H{"status": res}) // The response is sent to the client. The response is a JSON with the status code and the status. The status code is 200 and the status is the value of the item that was not added to the database map.
				break                                       // Break the for loop.
			} else { // If the ProduceCode of the item is not in the database map.
				item.UnitPrice = "$" + item.UnitPrice // Set the UnitPrice of the item to the value of the UnitPrice of the item. The UnitPrice of the item is a string.
				db[item.ProduceCode] = item           // Set the map key to the value of the ProduceCode of the item. The map key is a string. The map key is assigned to the ProduceCode of the item. The value of the ProduceCode of the item is the item.
				itemsAdded = true                     // Set the itemsAdded boolean to true.
			}
		}
		if itemsAdded { // If the itemsAdded boolean is true.
			res := "item added"                              // Create a new string. The string is created with the value "item added". The string is assigned to res.
			c.JSON(http.StatusCreated, gin.H{"status": res}) // The response is sent to the client. The response is a JSON with the status code and the status. The status code is 201 and the status is the value of the item that was added to the database map.
		}
	}
}

// Get Item godoc
// @Summary Get Item
// @Schemes
// @Description Get individual item by code like this: A12T-4GH7-QPL9-3N4M
// @Tags example
// @Param        code   path      string  true  "Code"
// @Accept json
// @Produce json
// @Success 200 {string} ok
// @Failure 400 {string} error
// @Router /item/:code [get]
func (db database) itemCode(c *gin.Context) { // Create a new route for the GET method on the /item/:code path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched.
	//localhost:8080/api/v1/item/A12T-4GH7-QPL9-3N4M
	dbmux.Lock()         // Lock the database map.
	defer dbmux.Unlock() // Unlock the database map.

	var produceId ProduceId                             // Create a new ProduceId. The ProduceId is used to store the ProduceCode of the item. The ProduceId is created empty. The ProduceId is assigned to produceId.
	if err := c.ShouldBindUri(&produceId); err != nil { // ShouldBindUri is a shortcut for c.ShouldBindWith(obj, binding.Uri).
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) // The response is sent to the client. The response is a JSON with the status code and the error. The status code is 400 and the error is the error message.
	} else { // If the ProduceCode of the item is in the database map.
		code := c.Param("code")      // Create a new string. The string is created with the value of the ProduceCode of the item. The string is assigned to code.
		code = strings.ToUpper(code) // Set the ProduceCode of the item to the upper case of the ProduceCode of the item. The ProduceCode of the item is a string.
		v, ok := db[code]            // Get the value of the ProduceCode of the item from the database map. The value of the ProduceCode of the item is a Item. The value of the ProduceCode of the item is assigned to v. The value of the ProduceCode of the item is assigned to the Item.
		if !ok {                     // If the value of the ProduceCode of the item is not in the database map.
			res := `code not found`                    // Create a new string. The string is created with the value of the item that was not found in the database map. The string is assigned to res.
			c.JSON(http.StatusOK, gin.H{"error": res}) // The response is sent to the client. The response is a JSON with the status code and the error. The status code is 200 and the error is the value of the item that was not found in the database map.
		} else { // If the value of the ProduceCode of the item is in the database map.
			var item Item                // Create a new Item. The Item is used to store the value of the item that was found in the database map. The Item is created empty. The Item is assigned to item.
			item.ProduceCode = code      // Set the ProduceCode of the item to the value of the ProduceCode of the item. The ProduceCode of the item is a string.
			item.Name = v.Name           // Set the Name of the item to the value of the Name of the item. The Name of the item is a string.
			item.UnitPrice = v.UnitPrice // Set the UnitPrice of the item to the value of the UnitPrice of the item. The UnitPrice of the item is a string. The UnitPrice of the item is assigned to the Item.
			c.JSON(http.StatusOK, item)  // The response is sent to the client. The response is a JSON with the status code and the item. The status code is 200 and the item is the value of the item that was found in the database map.
		}
	}
}

// Get Item godoc
// @Summary Get Item
// @Schemes
// @Description Get individual item by code
// @Tags example
// @Accept json
// @Produce json
// @Success 200 {string} ok
// @Failure 400 {string} error
// @Router /delete/:code [get]
func (db database) deleteCode(c *gin.Context) { // Create a new route for the GET method on the /delete/:code path. The handler function is called when the route is matched.  The handler function is a closure that accepts a context.Context as its only parameter.  The handler function returns a gin.H. The gin.H is a map of key/value pairs that are used to create the response. The response is sent to the client. The handler is called when the route is matched. The handler function is called when the route is matched.
	dbmux.Lock()                                        // Lock the database map.
	defer dbmux.Unlock()                                // Unlock the database map.
	var produceId ProduceId                             // Create a new ProduceId. The ProduceId is used to store the ProduceCode of the item. The ProduceId is created empty. The ProduceId is assigned to produceId.
	if err := c.ShouldBindUri(&produceId); err != nil { // ShouldBindUri is a shortcut for c.ShouldBindWith(obj, binding.Uri).
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) //  The response is sent to the client. The response is a JSON with the status code and the error. The status code is 400 and the error is the error message.
	} else { // If the ProduceCode of the item is in the database map.
		code := c.Param("code")      // Create a new string. The string is created with the value of the ProduceCode of the item. The string is assigned to code.
		code = strings.ToUpper(code) // Set the ProduceCode of the item to the upper case of the ProduceCode of the item. The ProduceCode of the item is a string. The ProduceCode of the item is assigned to the Item.
		_, ok := db[code]            // Get the value of the ProduceCode of the item from the database map. The value of the ProduceCode of the item is a Item. The value of the ProduceCode of the item is assigned to v. The value of the ProduceCode of the item is assigned to the Item.
		if !ok {                     //  If the value of the ProduceCode of the item is not in the database map.
			res := `code not found`                    // Create a new string. The string is created with the value of the item that was not found in the database map. The string is assigned to res.
			c.JSON(http.StatusOK, gin.H{"error": res}) // The response is sent to the client. The response is a JSON with the status code and the error. The status code is 200 and the error is the value of the item that was not found in the database map. The response is sent to the client. The response is a JSON with the status code and the error. The status code is 200 and the error is the value of the item that was not found in the database map.
		} else { // If the value of the ProduceCode of the item is in the database map.
			delete(db, code)                                       // Delete the value of the ProduceCode of the item from the database map. The value of the ProduceCode of the item is a Item. The value of the ProduceCode of the item is assigned to v. The value of the ProduceCode of the item is assigned to the Item. The value of the ProduceCode of the item is deleted from the database map.
			c.JSON(http.StatusOK, gin.H{"status": "item deleted"}) // The response is sent to the client. The response is a JSON with the status code and the status. The status code is 200 and the status is the value of the item that was deleted from the database map.
		}
	}
}

// end::setupRouter[]

//
// dbInit .
//
// .dbInit
// [source,go]
// ----
// include::${gad:current:fq}[tag=dbInit,indent=0]
// ----
// tag::dbInit[]
func (db database) dbInit() *gin.Engine {
	/* load test data */
	// Initialize initial data:
	var item Item                              // Create a new Item. The Item is used to store the value of the item that was found in the database map. The Item is created empty. The Item is assigned to item.
	item.Name = "Lettuce"                      //  Set the Name of the item to the value of the Name of the item. The Name of the item is a string. The Name of the item is assigned to the Item. The Name of the item is "Lettuce".
	item.UnitPrice = "$3.41"                   // Set the UnitPrice of the item to the value of the UnitPrice of the item. The UnitPrice of the item is a string. The UnitPrice of the item is assigned to the Item. The UnitPrice of the item is "$3.41". The UnitPrice of the item is assigned to the Item.
	db = database{"A12T-4GH7-QPL9-3N4M": item} // Set the database map to the value of the database map. The database map is a map. The database map is assigned to db. The database map is assigned to the database map.  The database map is initialized with the key of the item and the value of the item. The key of the item is a string. The value of the item is a Item. The key of the item is assigned to the Item. The value of the item is assigned to the Item. The key of the item is assigned to the database map. The value of the item is assigned to the database map.

	item.Name = "Peach"
	item.UnitPrice = "$2.99"
	db["E5T6-9UI3-TH15-QR88"] = item

	item.Name = "Green Pepper"
	item.UnitPrice = "$0.79"
	db["YRT6-72AS-K736-L4AR"] = item

	item.Name = "Gala Apple"
	item.UnitPrice = "$3.59"
	db["TQ4C-VV6T-75ZX-1RMR"] = item
	//
	// log.Printf("dbInit:%v", db)

	return db.setupRouter() // Return the router. The router is a Gin engine.
}

// end::dbInit[]

//
// main .
//
// .main
// [source,go]
// ----
// include::${gad:current:fq}[tag=main,indent=0]
// ----
// tag::main[]
func main() { // The main function is called. The main function is a function.
	// use the flags package to selectively enable profiling.
	// ./gcp-go-supermarket -profile.mode cpu
	// ./gcp-go-supermarket -profile.mode mem
	// ./gcp-go-supermarket -profile.mode mutex
	// ./gcp-go-supermarket -profile.mode block

	// -call_tree
	// go tool pprof -png -cum profile/cpu.pprof
	// go tool pprof -png -cum profile/mem.pprof
	// go tool pprof -png -cum profile/mutex.pprof
	// go tool pprof -png -cum profile/block.pprof

	mode := flag.String("profile.mode", "", "enable profiling mode, one of [cpu, mem, mutex, block]") // Create a new string. The string is created with the value of the mode. The string is assigned to mode.
	flag.Parse()                                                                                      // Parse the command line flags.

	switch *mode {
	case "cpu": // If the mode is cpu.
		fmt.Printf("cpu profiling enabled\n")
		defer profile.Start(profile.CPUProfile, profile.ProfilePath("./profile/")).Stop() // Create a new profile. The profile is created with the value of the CPUProfile. The profile is assigned to the profile. The profile is started with the value of the CPUProfile. The profile is started with the value of the profile. The profile is stopped when the call ends.
	case "mem": // If the mode is mem.
		fmt.Printf("mem profiling enabled\n")
		defer profile.Start(profile.MemProfile, profile.ProfilePath("./profile/")).Stop() // Create a new profile. The profile is created with the value of the MemProfile. The profile is assigned to the profile. The profile is started with the value of the MemProfile. The profile is started with the value of the profile. The profile is stopped when the call ends.
	case "mutex": // If the mode is mutex.
		fmt.Printf("mutex profiling enabled\n")
		defer profile.Start(profile.MutexProfile, profile.ProfilePath("./profile/")).Stop() // Create a new profile. The profile is created with the value of the MutexProfile. The profile is assigned to the profile. The profile is started with the value of the MutexProfile. The profile is stopped with the value of the profile. The profile is stopped when the call ends.
	case "block": // If the mode is block.
		fmt.Printf("block profiling enabled\n")
		defer profile.Start(profile.BlockProfile, profile.ProfilePath("./profile/")).Stop() // Create a new profile. The profile is created with the value of the BlockProfile. The profile is assigned to the profile. The profile is started with the value of the BlockProfile. The profile is stopped with the value of the profile. The profile is stopped when the call ends.
	default:
		// do nothing
	}
	db := database{} // Create a new database. The database is used to store the database map. The database is created empty. The database is assigned to db. The database is assigned to the database.
	r := db.dbInit()
	// use ginSwagger middleware to serve the API docs
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// It then calls http.ListenAndServe, specifying that it should listen
	// on port 8080 on any interface (":8080").
	// This function will block until the program is terminated.

	// Custom HTTP configuration
	// Create a custom server for using in production instead of using the default one:
	// The reason is the default http.Server is created with Timeout 0, which means no timeout.
	// This means when the server has outage or something like that,
	// the connection from the client will be hang forever and will cause the user request
	// (if one is associated) to be hang as well.
	//
	// ReadTimeout covers the time from when the connection is accepted to when
	// the request body is fully read
	//
	// WriteTimeout normally covers the time from the end of the request header
	// read to the end of the response write (a.k.a. the lifetime of the ServeHTTP),
	// by calling SetWriteDeadline at the end of readRequest.
	s := &http.Server{ // Create a new http.Server. The http.Server is used to store the value of the http.Server. The http.Server is created empty. The http.Server is assigned to s. The http.Server is assigned to the http.Server.
		Addr:         ":8080",          // Set the Addr of the http.Server to the value of the Addr of the http.Server. The Addr of the http.Server is a string. The Addr of the http.Server is assigned to the http.Server. The Addr of the http.Server is ":8080". The Addr of the http.Server is assigned to the http.Server.
		Handler:      r,                // Set the Handler of the http.Server to the value of the Handler of the http.Server. The Handler of the http.Server is a http.Handler. The Handler of the http.Server is assigned to the http.Server. The Handler of the http.Server is the router. The router is a Gin engine.
		ReadTimeout:  5 * time.Second,  // Set the ReadTimeout of the http.Server to the value of the ReadTimeout of the http.Server. The ReadTimeout of the http.Server is a time.Duration. The ReadTimeout of the http.Server is assigned to the http.Server. The ReadTimeout of the http.Server is 5 seconds. The ReadTimeout of the http.Server is assigned to the http.Server.
		WriteTimeout: 10 * time.Second, // Set the WriteTimeout of the http.Server to the value of the WriteTimeout of the http.Server. The WriteTimeout of the http.Server is a time.Duration. The WriteTimeout of the http.Server is assigned to the http.Server. The WriteTimeout of the http.Server is 10 seconds. The WriteTimeout of the http.Server is assigned to the http.Server.
	}
	s.ListenAndServe() // ListenAndServe is a blocking call that will listen on the Addr and then accept and serve incoming connections. It will block until the program is terminated.
}

// end::main[]

const (
	// represents the 4 characters from a-f, A-F, and 0-9 that is repeated 3 times separated by a hyphen (-).
	uUIDRegexString = "^[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}$" //
	// * - match 0 or more of the preceding token
	alphaNumericAndSpaceRegexString = "^[a-zA-Z0-9 ]*$"
	//represents a number with up to 2 decimal places
	unitPriceString = "^\\d+\\.\\d{1,2}$"
)

var ( // The following are used to validate the data that is being sent to the server.
	uUIDRegex                 = regexp.MustCompile(uUIDRegexString)                 // The uUIDRegex is used to validate the uUID. The uUIDRegex is a regexp.Regexp. The uUIDRegex is created from the uUIDRegexString. The uUIDRegexString is a string. The uUIDRegexString is assigned to the uUIDRegex.
	alphaNumericAndSpaceRegex = regexp.MustCompile(alphaNumericAndSpaceRegexString) // The alphaNumericAndSpaceRegex is used to validate the alphaNumericAndSpace. The alphaNumericAndSpaceRegex is a regexp.Regexp. The alphaNumericAndSpaceRegex is created from the alphaNumericAndSpaceRegexString. The alphaNumericAndSpaceRegexString is a string. The alphaNumericAndSpaceRegexString is assigned to the alphaNumericAndSpaceRegex.
	unitPriceRegex            = regexp.MustCompile(unitPriceString)                 // The unitPriceRegex is used to validate the unitPrice. The unitPriceRegex is a regexp.Regexp. The unitPriceRegex is created from the unitPriceString. The unitPriceString is a string. The unitPriceString is assigned to the unitPriceRegex.
)

// isUUID is the validation function for validating if the field's value is a valid custom UUID.
func isUUID(fl validator.FieldLevel) bool { // The isUUID function is used to validate the field's value is a valid custom UUID. The isUUID function is a function. The isUUID function is assigned to the isUUID function.
	return uUIDRegex.MatchString(fl.Field().String()) // The MatchString function is used to validate the field's value is a valid custom UUID. The MatchString function is a function. The MatchString function is assigned to the MatchString function. The MatchString function is called with the field's value as the argument.
}

// isAlphaNumericAndSpace is the validation function for validating if the current field
// is an almanumeric string which can contain spaces.
func isAlphaNumericAndSpace(fl validator.FieldLevel) bool { // The isAlphaNumericAndSpace function is used to validate if the current field is an almanumeric string which can contain spaces. The isAlphaNumericAndSpace function is a function. The isAlphaNumericAndSpace function is assigned to the isAlphaNumericAndSpace function.
	return alphaNumericAndSpaceRegex.MatchString(fl.Field().String()) // The MatchString function is used to validate if the current field is an almanumeric string which can contain spaces. The MatchString function is a function. The MatchString function is assigned to the MatchString function. The MatchString function is called with the field's value as the argument.
}

func IsProduceCode(fl validator.FieldLevel) bool { // The IsProduceCode function is used to validate if the current field is a valid produce code. The IsProduceCode function is a function. The IsProduceCode function is assigned to the IsProduceCode function.
	return isUUID(fl) // The isUUID function is used to validate if the current field is a valid custom UUID. The isUUID function is a function. The isUUID function is assigned to the isUUID function.
}

// IsUnitPrice is the validation function for validating if the current field
// is a number with up to 2 decimal places
func IsUnitPrice(fl validator.FieldLevel) bool { // The IsUnitPrice function is used to validate if the current field is a number with up to 2 decimal places. The IsUnitPrice function is a function. The IsUnitPrice function is assigned to the IsUnitPrice function.
	return unitPriceRegex.MatchString(fl.Field().String()) // The MatchString function is used to validate if the current field is a number with up to 2 decimal places. The MatchString function is a function. The MatchString function is assigned to the MatchString function. The MatchString function is called with the field's value as the argument.
}
